#!/bin/bash
### BEGIN INIT INFO
# Provides:          cloud-early-config
# Required-Start:    $local_fs
# Required-Stop:     $local_fs
# Default-Start:     S
# Default-Stop:      0 6
# Short-Description: configures systemvm using cmdline
### END INIT INFO
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

#set -x
#exec 3>&0 4>&1 > /var/log/test.log 2>&1
PATH="/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin"

# Clear boot up flag, it would be created by rc.local after boot up done
rm -f /var/cache/cloud/boot_up_done

[ -x /sbin/ifup ] || exit 0

. /lib/lsb/init-functions


log_it() {
  echo "$(date) $@" >> /var/log/cloud.log
  log_action_msg "$@"
}


hypervisor() {
  [ -d /proc/xen ] && mount -t xenfs none /proc/xen
  [ -d /proc/xen ] && echo "xen-domU" && return 0

  local try=$([ -x /usr/sbin/virt-what ] && virt-what | tail -1)
  [ "$try" != "" ] && echo $try && return 0

  vmware-checkvm &> /dev/null && echo "vmware" && return 0

  grep -q QEMU /proc/cpuinfo  && echo "kvm" && return 0
  grep -q QEMU /var/log/messages && echo "kvm" && return 0

  echo "unknown" && return 1
}


config_guest() {
  [ -f /usr/sbin/hv_kvp_daemon ] && /usr/sbin/hv_kvp_daemon
  [ ! -d /proc/xen ] && sed -i 's/^vc/#vc/' /etc/inittab && telinit q
  [  -d /proc/xen ] && sed -i 's/^#vc/vc/' /etc/inittab && telinit q
}


get_boot_params() {
  case $HYPERVISOR in
     xen-domU|xen-hvm)
          cat /proc/cmdline > /var/cache/cloud/cmdline
          sed -i "s/%/ /g" /var/cache/cloud/cmdline
          ;;
     kvm)
          VPORT=$(find /dev/virtio-ports -type l -name '*.vport' 2>/dev/null|head -1)

          if [ -z "$VPORT" ]; then
            log_it "No suitable VirtIO port was found in /dev/virtio-ports" && exit 2
          fi

          if [ ! -e "$VPORT" ]; then
            log_it "${VPORT} not loaded, perhaps guest kernel is too old." && exit 2
          fi

          local factor=2
          local progress=1
          for i in {1..5}
          do
            while read line; do
              if [[ $line == cmdline:* ]]; then
                cmd=${line//cmdline:/}
                echo $cmd > /var/cache/cloud/cmdline
              elif [[ $line == pubkey:* ]]; then
                pubkey=${line//pubkey:/}
                echo $pubkey > /var/cache/cloud/authorized_keys
                echo $pubkey > /root/.ssh/authorized_keys
              fi
            done < $VPORT
            # In case of reboot we do not send the boot args again.
            # So, no need to wait for them, as the boot args are already set at startup
            if [ -s /var/cache/cloud/cmdline  ]
            then
              log_it "Found a non empty cmdline file. Will now exit the loop and proceed with configuration."
              break;
            fi
            sleep ${progress}s
            progress=$[ progress * factor ]
          done
          chmod go-rwx /root/.ssh/authorized_keys
          ;;
     vmware)
          vmtoolsd --cmd 'machine.id.get' > /var/cache/cloud/cmdline 
          ;;
     virtualpc|hyperv)
          # Hyper-V is recognized as virtualpc hypervisor type. Boot args are passed using KVP Daemon
          #waiting for the hv_kvp_daemon to start up
          #sleep  need to fix the race condition of hv_kvp_daemon and cloud-early-config
          sleep 5
          cp -f /var/opt/hyperv/.kvp_pool_0 /var/cache/cloud/cmdline
          cat /dev/null > /var/opt/hyperv/.kvp_pool_0
          ;;
     virtualbox)
          # Virtualbox is used to test the virtual router
          # get the commandline from a dmistring  (yes, hacky!)
          dmidecode | grep cmdline | sed 's/^.*cmdline://' > /var/cache/cloud/cmdline
          RV=$?
          if [ $RV -ne 0 ] ; then
            log_it "Failed to get cmdline from a virtualbox dmi property"
          fi
          ;;
  esac
}


parse_cmd_line() {
  CMDLINE=$(cat /var/cache/cloud/cmdline)
  TYPE="unknown"
  BOOTPROTO="static"
  DISABLE_RP_FILTER="false"
  STORAGE_IP=""
  STORAGE_NETMASK=""
  STORAGE_CIDR=""
  VM_PASSWORD=""

  CHEF_TMP_FILE=/tmp/cmdline.json
  COMMA="\t"
  echo -e "{\n\"type\": \"cmdline\"," > ${CHEF_TMP_FILE}
  echo -e "\n\"cmd_line\": {" >> ${CHEF_TMP_FILE}

  for i in $CMDLINE
    do
      # search for foo=bar pattern and cut out foo
      KEY=$(echo $i | cut -d= -f1)
      VALUE=$(echo $i | cut -d= -f2)
      echo -en ${COMMA} >> ${CHEF_TMP_FILE}
      # Two lines so values do not accidently interpretted as escapes!!
      echo -n \"${KEY}\"': '\"${VALUE}\" >> ${CHEF_TMP_FILE}
      COMMA=",\n\t"
      case $KEY in
        disable_rp_filter)
            export DISABLE_RP_FILTER=$VALUE
            ;;
        eth0ip)
            export ETH0_IP=$VALUE
            ;;
        eth1ip)
            export ETH1_IP=$VALUE
            ;;
        eth2ip)
            export ETH2_IP=$VALUE
            ;;
        host)
            export MGMT_HOST=$VALUE
            ;;
        gateway)
            export GW=$VALUE
            ;;
        ip6gateway)
            export IP6GW=$VALUE
            ;;
        eth0mask)
            export ETH0_MASK=$VALUE
            ;;
        eth1mask)
            export ETH1_MASK=$VALUE
            ;;
        eth2mask)
            export ETH2_MASK=$VALUE
            ;;
        eth0ip6)
            export ETH0_IP6=$VALUE
            ;;
        eth0ip6prelen)
            export ETH0_IP6_PRELEN=$VALUE
            ;;
        internaldns1)
            export internalNS1=$VALUE
            ;;
        internaldns2)
            export internalNS2=$VALUE
            ;;
        dns1)
            export NS1=$VALUE
            ;;
        dns2)
            export NS2=$VALUE
            ;;
        ip6dns1)
            export IP6_NS1=$VALUE
            ;;
        ip6dns2)
            export IP6_NS2=$VALUE
            ;;
        domain)
            export DOMAIN=$VALUE
            ;;
        dnssearchorder)
            export DNS_SEARCH_ORDER=$VALUE
            ;;
        useextdns)
            export USE_EXTERNAL_DNS=$VALUE
            ;;
        mgmtcidr)
            export MGMTNET=$VALUE
            ;;
        localgw)
            export LOCAL_GW=$VALUE
            ;;
        template)
            export TEMPLATE=$VALUE
            ;;
        sshonguest)
            export SSHONGUEST=$VALUE
            ;;
        name)
            export NAME=$VALUE
            ;;
        dhcprange)
            export DHCP_RANGE=$(echo $VALUE | tr ':' ',')
            ;;
        bootproto)
            export BOOTPROTO=$VALUE
            ;;
        type)
            export TYPE=$VALUE
            ;;
        defaultroute)
            export DEFAULTROUTE=$VALUE
            ;;
        redundant_router)
            export RROUTER=$VALUE
            ;;
        guestgw)
            export GUEST_GW=$VALUE
            ;;
        guestbrd)
            export GUEST_BRD=$VALUE
            ;;
        guestcidrsize)
            export GUEST_CIDR_SIZE=$VALUE
            ;;
        router_pr)
            export ROUTER_PR=$VALUE
            ;;
        extra_pubnics)
            export EXTRA_PUBNICS=$VALUE
            ;;
        nic_macs)
            export NIC_MACS=$VALUE
            ;;
        mtu)
            export MTU=$VALUE
            ;;
        storageip)
            export STORAGE_IP=$VALUE
            ;;
        storagenetmask)
            export STORAGE_NETMASK=$VALUE
            ;;
        storagecidr)
            export STORAGE_CIDR=$VALUE
            ;;
        vmpassword)
            export VM_PASSWORD=$VALUE
            ;;
        vpccidr)
            export VPCCIDR=$VALUE
            ;;
        cidrsize)
            export CIDR_SIZE=$VALUE
            ;;
        advert_int)
            export ADVERT_INT=$VALUE
            ;;
        ntpserverlist)
            export NTP_SERVER_LIST=$VALUE
            ;;
      esac
  done
  echo -e "\n\t}\n}" >> ${CHEF_TMP_FILE}
  if [ "$TYPE" != "unknown" ]
  then
    mv ${CHEF_TMP_FILE} /var/cache/cloud/cmd_line.json
  fi

  [ $ETH0_IP ] && export LOCAL_ADDRS=$ETH0_IP
  [ $ETH0_IP6 ] && export LOCAL_ADDRS=$ETH0_IP6
  [ $ETH0_IP ] && [ $ETH0_IP6 ] && export LOCAL_ADDRS="$ETH0_IP,$ETH0_IP6"
}


patch() {
  local PATCH_MOUNT=/media/cdrom
  local patchfile=$PATCH_MOUNT/cloud-scripts.tgz
  local privkey=$PATCH_MOUNT/authorized_keys
  local md5file=/var/cache/cloud/cloud-scripts-signature
  local cdrom_dev=
  mkdir -p $PATCH_MOUNT

  if [ -e /dev/xvdd ]; then
       cdrom_dev=/dev/xvdd
  elif [ -e /dev/cdrom ]; then
       cdrom_dev=/dev/cdrom
  elif [ -e /dev/cdrom1 ]; then
       cdrom_dev=/dev/cdrom1
  elif [ -e /dev/cdrom2 ]; then
       cdrom_dev=/dev/cdrom2
  elif [ -e /dev/cdrom3 ]; then
       cdrom_dev=/dev/cdrom3
  fi

  [ -f /var/cache/cloud/authorized_keys ] && privkey=/var/cache/cloud/authorized_keys

  if [ -n "$cdrom_dev" ]; then
    mount -o ro $cdrom_dev $PATCH_MOUNT
    [ -f $privkey ] && cp -f $privkey /root/.ssh/ && chmod go-rwx /root/.ssh/authorized_keys
    local oldmd5=
    [ -f ${md5file} ] && oldmd5=$(cat ${md5file})
    local newmd5=
    [ -f ${patchfile} ] && newmd5=$(md5sum ${patchfile} | awk '{print $1}')

    log_it "Scripts checksum detected: oldmd5=$oldmd5 newmd5=$newmd5"
    if [ "$oldmd5" != "$newmd5" ] && [ -f ${patchfile} ] && [ "$newmd5" != "" ]
    then
      tar xzf $patchfile -C /
      echo ${newmd5} > ${md5file}
      log_it "Patched scripts using $patchfile"
      sync
    fi

    log_it "Patching cloud service"
    /opt/cloud/bin/setup/patchsystemvm.sh $PATCH_MOUNT $HYPERVISOR $TYPE
    umount $PATCH_MOUNT
  fi

  if [ -f /mnt/cmdline ]; then
    cat /mnt/cmdline > /var/cache/cloud/cmdline
    parse_cmd_line
  fi

  return 0
}


change_password() {
  # Randomize cloud password so only ssh login is allowed
  echo "cloud:`openssl rand -base64 32`" | chpasswd

  if [ x"$VM_PASSWORD" != x"" ]
  then
    echo "root:$VM_PASSWORD" | chpasswd
  fi
}


start() {
  # Clear /tmp for file lock
  rm -f /tmp/*.lock
  rm -f /tmp/rrouter_bumped

  export HYPERVISOR=$(hypervisor)
  [ $? -ne 0 ] && log_it "Failed to detect hypervisor type, bailing out of early init" && exit 10
  log_it "Detected that we are running inside $HYPERVISOR"

  config_guest
  get_boot_params
  parse_cmd_line
  patch
  change_password

  if [ -f "/opt/cloud/bin/setup/$TYPE.sh" ]; then
      /opt/cloud/bin/setup/$TYPE.sh
  else
      /opt/cloud/bin/setup/default.sh
  fi

  return 0
}


case "$1" in
  start)
    log_action_begin_msg "Executing cloud-early-config"
    log_it "Executing cloud-early-config"
    if start; then
        log_action_end_msg $?
    else
        log_action_end_msg $?
    fi
    ;;

  stop)
    log_action_begin_msg "Stopping cloud-early-config"
    #Override old system's interface setting
    setup_default;
    log_action_end_msg 0
    ;;

  force-reload|restart)
    log_warning_msg "Running $0 is deprecated because it may not enable again some interfaces"
    log_action_begin_msg "Executing cloud-early-config"
    if start; then
        log_action_end_msg $?
    else
        log_action_end_msg $?
    fi
    ;;

  *)
    echo "Usage: /etc/init.d/cloud-early-config {start|stop}"
    exit 1
    ;;
esac

exit 0
